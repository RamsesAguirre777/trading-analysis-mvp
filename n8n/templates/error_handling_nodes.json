{
  "error_handling_nodes": {
    "api_error_handler": {
      "name": "API Error Handler",
      "type": "n8n-nodes-base.code",
      "parameters": {
        "jsCode": "// API Error Handling and Retry Logic\nconst maxRetries = 3;\nconst retryDelay = 5000; // 5 seconds\nconst currentRetry = $node.context.get('retry_count') || 0;\n\n// Get the last error\nconst lastError = $input.all()[0]?.error;\nconst errorMessage = lastError?.message || 'Unknown API error';\n\n// Log error details\nconsole.log(`API Error (Retry ${currentRetry}/${maxRetries}): ${errorMessage}`);\n\n// Check if we should retry\nif (currentRetry < maxRetries) {\n  // Increment retry counter\n  $node.context.set('retry_count', currentRetry + 1);\n  \n  // Wait before retry\n  await new Promise(resolve => setTimeout(resolve, retryDelay * currentRetry));\n  \n  // Return error for retry\n  throw new Error(`Retrying API call (${currentRetry + 1}/${maxRetries}): ${errorMessage}`);\n} else {\n  // Max retries exceeded, use fallback or fail gracefully\n  console.log('Max retries exceeded, attempting fallback...');\n  \n  // Reset retry counter for next execution\n  $node.context.set('retry_count', 0);\n  \n  // Return fallback data or error\n  return [{\n    json: {\n      error: true,\n      message: `API failed after ${maxRetries} retries: ${errorMessage}`,\n      fallback_used: true,\n      timestamp: new Date().toISOString()\n    }\n  }];\n}"
      },
      "settings": {
        "continueOnFail": true,
        "retryOnFail": true,\n        \"retryInterval\": 5000\n      }\n    },\n    \"calculator_error_handler\": {\n      \"name\": \"Calculator Error Handler\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"parameters\": {\n        \"jsCode\": \"// Trading Calculator Error Handling\\nconst executionResult = $input.all()[0];\\nconst stdout = executionResult?.json?.stdout || '';\\nconst stderr = executionResult?.json?.stderr || '';\\nconst exitCode = executionResult?.json?.exitCode;\\n\\n// Check for execution errors\\nif (exitCode !== 0 || stderr.trim() !== '') {\\n  const errorMessage = stderr || `Calculator exited with code ${exitCode}`;\\n  console.error('Trading Calculator Error:', errorMessage);\\n  \\n  // Create error response\\n  return [{\\n    json: {\\n      error: true,\\n      error_type: 'calculator_execution',\\n      message: errorMessage,\\n      timestamp: new Date().toISOString(),\\n      // Fallback analysis with minimal data\\n      analysis_result: {\\n        symbol: 'UNKNOWN',\\n        error: true,\\n        trading_signals: {\\n          primary_direction: 'HOLD',\\n          confidence: 0.0,\\n          entry_levels: [],\\n          stop_loss: null,\\n          take_profit: [],\\n          risk_reward: 0\\n        }\\n      }\\n    }\\n  }];\\n}\\n\\n// Try to parse stdout as JSON\\ntry {\\n  const analysisResult = JSON.parse(stdout);\\n  \\n  // Validate required fields\\n  if (!analysisResult.trading_signals) {\\n    throw new Error('Missing trading_signals in calculator output');\\n  }\\n  \\n  return [{ json: analysisResult }];\\n} catch (parseError) {\\n  console.error('JSON Parse Error:', parseError.message);\\n  \\n  return [{\\n    json: {\\n      error: true,\\n      error_type: 'json_parse',\\n      message: `Failed to parse calculator output: ${parseError.message}`,\\n      raw_output: stdout,\\n      timestamp: new Date().toISOString()\\n    }\\n  }];\\n}\"\n      }\n    },\n    \"telegram_error_handler\": {\n      \"name\": \"Telegram Error Handler\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"parameters\": {\n        \"jsCode\": \"// Telegram Send Error Handling\\nconst telegramError = $input.all()[0]?.error;\\nconst originalMessage = $('Format Telegram Message').item?.json?.message || 'Unknown message';\\n\\nif (telegramError) {\\n  console.error('Telegram Send Error:', telegramError.message);\\n  \\n  // Try to send simplified message\\n  const fallbackMessage = `🚨 ALERT DELIVERY FAILED\\\\n\\\\nOriginal message could not be delivered.\\\\nCheck N8N logs for details.\\\\n\\\\n⏰ ${new Date().toLocaleString()}`;\\n  \\n  return [{\\n    json: {\\n      message: fallbackMessage,\\n      fallback: true,\\n      original_error: telegramError.message\\n    }\\n  }];\\n}\\n\\n// If no error, pass through original\\nreturn [{ json: { message: originalMessage } }];\"\n      },\n      \"settings\": {\n        \"continueOnFail\": true\n      }\n    },\n    \"fallback_data_provider\": {\n      \"name\": \"Fallback Data Provider\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"parameters\": {\n        \"jsCode\": \"// Fallback data when APIs fail\\nconst symbol = $('Webhook Trigger').item?.json?.symbol || 'UNKNOWN';\\nconst apiErrors = $input.all().filter(item => item.json?.error);\\n\\nif (apiErrors.length > 0) {\\n  console.log('Using fallback data due to API errors');\\n  \\n  // Use cached data or default values\\n  const fallbackData = {\\n    symbol: symbol,\\n    previous_day: {\\n      high: 100.0,\\n      low: 95.0,\\n      close: 98.0,\\n      change: 2.0\\n    },\\n    current_day: {\\n      high: 102.0,\\n      low: 97.0,\\n      current_price: 100.0,\\n      change: 2.0\\n    },\\n    manual_break_points: {\\n      break_point: null,\\n      max_pos_exp: null,\\n      int_pos_exp: null,\\n      int_neg_exp: null,\\n      max_neg_exp: null\\n    },\\n    bollinger_bands: {\\n      premarket_bbt_1h: 105.0,\\n      premarket_bbb_1h: 95.0,\\n      market_close_bbt_1h: 104.0,\\n      market_close_bbb_1h: 94.0\\n    },\\n    emas_1h: {\\n      ema20: 99.0,\\n      ema50: 98.0,\\n      ema200: 95.0\\n    },\\n    fallback_data: true,\\n    error_reason: 'API failures, using cached/default data'\\n  };\\n  \\n  return [{ json: fallbackData }];\\n}\\n\\n// If no errors, pass through original data\\nreturn $input.all();\"\n      }\n    },\n    \"notification_error_logger\": {\n      \"name\": \"Error Logger & Notification\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"parameters\": {\n        \"jsCode\": \"// Log errors and send notifications\\nconst errors = $input.all().filter(item => item.json?.error);\\nconst symbol = $('Webhook Trigger').item?.json?.symbol || 'UNKNOWN';\\n\\nif (errors.length > 0) {\\n  const errorSummary = {\\n    timestamp: new Date().toISOString(),\\n    symbol: symbol,\\n    error_count: errors.length,\\n    errors: errors.map(err => ({\\n      type: err.json.error_type || 'unknown',\\n      message: err.json.message || 'Unknown error',\\n      node: err.json.node || 'unknown'\\n    }))\\n  };\\n  \\n  // Log to console\\n  console.error('Trading Analysis Errors:', JSON.stringify(errorSummary, null, 2));\\n  \\n  // Create admin notification\\n  const adminMessage = `🚨 TRADING ANALYSIS ERRORS\\\\n\\\\nSymbol: ${symbol}\\\\nErrors: ${errors.length}\\\\nTime: ${new Date().toLocaleString()}\\\\n\\\\nDetails:\\\\n${errors.map(err => `• ${err.json.error_type}: ${err.json.message}`).join('\\\\n')}`;\\n  \\n  return [{\\n    json: {\\n      error_summary: errorSummary,\\n      admin_notification: adminMessage,\\n      send_admin_alert: true\\n    }\\n  }];\\n}\\n\\n// No errors to report\\nreturn [{ json: { errors: 0, status: 'success' } }];\"\n      }\n    }\n  },\n  \"retry_strategies\": {\n    \"exponential_backoff\": {\n      \"description\": \"Exponential backoff retry strategy\",\n      \"implementation\": \"delay = base_delay * (2 ^ retry_count)\",\n      \"max_retries\": 3,\n      \"base_delay_ms\": 1000\n    },\n    \"linear_backoff\": {\n      \"description\": \"Linear backoff retry strategy\",\n      \"implementation\": \"delay = base_delay * retry_count\",\n      \"max_retries\": 5,\n      \"base_delay_ms\": 2000\n    },\n    \"fixed_delay\": {\n      \"description\": \"Fixed delay retry strategy\",\n      \"implementation\": \"delay = fixed_delay\",\n      \"max_retries\": 3,\n      \"delay_ms\": 5000\n    }\n  },\n  \"error_categories\": {\n    \"api_timeout\": {\n      \"retry\": true,\n      \"max_retries\": 3,\n      \"fallback\": \"cached_data\"\n    },\n    \"api_rate_limit\": {\n      \"retry\": true,\n      \"delay_multiplier\": 2,\n      \"max_retries\": 5\n    },\n    \"api_unauthorized\": {\n      \"retry\": false,\n      \"alert_admin\": true,\n      \"fallback\": \"none\"\n    },\n    \"calculator_error\": {\n      \"retry\": true,\n      \"max_retries\": 2,\n      \"fallback\": \"default_analysis\"\n    },\n    \"telegram_failed\": {\n      \"retry\": true,\n      \"fallback\": \"email_notification\"\n    }\n  }\n}"